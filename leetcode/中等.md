## 中等难度

1. 子集
> 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:
```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

**思路：采用回溯法，递归得出结果**

```javascript
var subsets = function(nums) {
	let res = [];
	let temp = [];
	back(0, nums, res, temp);
	return res;
};

function back(i,nums,res,temp) {
	res.push([...temp]);
	for(let j=i;j<nums.length;j++) {
		temp.push(nums[j]);
		back(j+1,nums,res,temp);
		temp.pop();
	}
}
```
----
![leetcode截图](./image/1568464389.jpg)

**思路：迭代**
```javascript
/*
* 后面的数由前面的数迭代生成，比如输入[1,2,3], 首先子集有一个空子集[]，当遍历到1时，子集有空子集加1生* 成[1],此时子集有[[],[1]],当遍历到2时，子集有空子集加2生成[2]，以及[1]加2,生成[1,2],子集此时有[[],* [1],[2],[1,2]]，当遍历到3，子集有空子集加3生成[3]，以及[1]加3,[1,3],[2]加3,[2,3].[1,2]加3,[1,2,* 3],因此得出解[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]];
*
*/
var subsets = function(nums) {
	let res = [[]];

	for(let i=0;i<nums.length;i++) {
		for(let j=0,len=res.length;j<len;j++) {
			res.push(res[j].concat(nums[i]));
		}	
	}

	return res;
};
```
----
![leetcode截图](./image/1568466968.jpg)

2. 括号生成
>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

例如，给出 n = 3，生成结果为：
```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

**思路：采用回溯法**

```javascript
/*
* 解法：通过递归回溯进行解题，用两个变量标识左括号和右括号的数量，一个左括号对应一个右括号，当左括号的数* 量大于右括号时，右括号才能填入。
*/
var generateParenthesis = function(n) {

	let res = [];

	helper('', n, 0, 0, res);
	return res;
};

function helper(str, n, left, right, res) {
	if( str.length === n * 2) {
		res.push(str);
		return;
	};

	if(left < n) {
		helper(str + '(', n, left+1, right, res);
	};

	if(left > right) {
		helper(str + ')', n, left, right+1, res)
	}
};
```
----
![leetcode截图](./image/1568549540.jpg)

3. 全排列
>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

示例:
```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

**思路：采用回溯法**

```javascript
/*
* 解法：通过递归回溯进行解题，先把所有可能性画出来，变成一颗树，然后用深度优先搜索加回溯得出所有节点
*/
var permute = function(nums) {
    let res = [];

    helper(0, nums, res, []);

    return res;  
};

function helper(i, arr, res, temp) {
    if(i === arr.length) {
        res.push([...temp]);
        return;
    };

    for(let j=i;j<arr.length;j++) {
        temp.push(arr[j]);
        let newArr = arr.slice(0,j).concat(arr.slice(j+1))
        helper(i,newArr, res, temp);
        temp.pop();
    };
}
```
----
![leetcode截图](./image/1568615339.jpg)

4. 组合
>给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:
```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**思路：采用回溯法**

```javascript
/*
* 解法：通过递归回溯进行解题，先把所有可能性画出来，变成一颗树，然后用深度优先搜索加回溯得出所有节点
*/
var combine = function(n, k) {
    let res = [];

    helper(0, k, n, res , []);

    return res;
};

function helper(i, k, n, res, temp) {
    if(temp.length === k) {
        res.push([...temp]);
        return;
    };

    for(let j=i; j<n;j++) {
        temp.push(j+1);
        helper(j+1,k,n,res,temp);
        temp.pop();
    };

};
```
----
![leetcode截图](./image/1568796179.jpg)

5. 活字印刷
>你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。

示例1:
```
输入："AAB"
输出：8
解释：可能的序列为 "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"。
```

示例2:
```
输入："AAABBC"
输出：188
```

提示：
1 <= tiles.length <= 7
tiles 由大写英文字母组成


**思路：采用回溯法**

```javascript
/*
* 解法：通过递归回溯进行解题，先把所有可能性画出来，变成一颗树，然后用深度优先搜索加回溯得出所有节点
*/
var numTilePossibilities = function(tiles) {
    let res = [];

    for(let i=0; i<tiles.length; i++) {
        helper(0, i+1, tiles, res, '');
    };

    return [...new Set(res)].length;
};

function helper(i, j, tiles, res, temp) {
    if(temp.length === j) {
        res.push(temp);
        return;
    };

    for(let k=i;k<tiles.length;k++) {
        temp += tiles[k];
        let newStr = tiles.substring(0, k) + tiles.substring(k+1);
        helper(0, j, newStr, res, temp);
        temp = temp.substring(0,temp.length-1);
    };
};
```
----
![leetcode截图](./image/1568878391.jpg)

6. 组合总和
>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

示例1:
```
输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
```

示例2:
```
输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```


**思路：采用回溯法**

```javascript
/*
* 解法：通过递归回溯进行解题，先把所有可能性画出来，变成一颗树，然后用深度优先搜索加回溯得出所有节点
*/
var combinationSum = function(candidates, target) {
    let res = [];
    helper(0, candidates, res, target, [], 0);
    return res;
};


function helper(i, candidates, res, target, temp, sum) {
    if(sum === target) {
        res.push([...temp]);
        return;
    };

    for(let j=i; j<candidates.length;j++) {
        if( sum < target ) {
            sum += candidates[j];
            temp.push(candidates[j]);
            helper(j, candidates, res, target, temp, sum);
            sum -= temp.pop();
        };
    };
    
};
```
----
![leetcode截图](./image/1568973754.jpg)

7. 组合总和 II
>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用一次。candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 

示例1:
```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

示例2:
```
输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]
```


**思路：采用回溯法**

```javascript
/*
* 解法：通过递归回溯进行解题，先把所有可能性画出来，变成一颗树，然后用深度优先搜索加回溯得出所有节点
*/
var combinationSum2 = function(candidates, target) {
    let res = [];
    candidates.sort();
    helper(0,candidates, target, res, 0, []);
    return res
};

function helper(i,candidates, target, res, sum, temp) {
    if(sum > target) return;
    
    if(sum == target ) {
        res.push([...temp]);
        return;
    };

    let old = null;
    for(let j=i; j<candidates.length; j++) {
        if( old === candidates[j] ) {
            continue;
        }else {
            old = candidates[j];
        }
        sum += candidates[j];
        temp.push(candidates[j])
        helper(j+1, candidates, target, res, sum, temp);
        sum -= temp.pop();
    };

}
```
----
![leetcode截图](./image/1569322495.jpg)

8. 组合总和 III
>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。

示例1:
```
输入: k = 3, n = 7
输出: [[1,2,4]]
```

示例2:
```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
```


**思路：采用回溯法**

```javascript
/*
* 解法：通过递归回溯进行解题，先把所有可能性画出来，变成一颗树，然后用深度优先搜索加回溯得出所有节点
*/
var combinationSum3 = function(k, n) {
    let res = [];
    helper(1, k, n, res, 0, []);
    return res;
};

function helper(i, k, n, res, sum, temp) {
    if(sum > n || temp.length > k) return;
    if(temp.length === k && sum === n ) {
        res.push([...temp]);
        return;
    };

    for(let j=i; j<=9; j++) {
        sum += j;
        temp.push(j);
        helper(j+1, k, n, res, sum, temp);
        sum -= temp.pop();
    };

};
```
----
![leetcode截图](./image/1569408599.jpg)

9. 组合总和 III
>给定一个数组 A，将其划分为两个不相交（没有公共元素）的连续子数组 left 和 right， 使得：
>left 中的每个元素都小于或等于 right 中的每个元素。
>left 和 right 都是非空的。
>left 要尽可能小。
>在完成这样的分组后返回 left 的长度。可以保证存在这样的划分方法。

说明：

所有数字都是正整数。
解集不能包含重复的组合。

示例1:
```
输入：[5,0,3,8,6]
输出：3
解释：left = [5,0,3]，right = [8,6]
```

示例2:
```
输入：[1,1,1,0,6,12]
输出：4
解释：left = [1,1,1,0]，right = [6,12]
```
提示：

1. 2 <= A.length <= 30000
2. 0 <= A[i] <= 10^6
可以保证至少有一种方法能够按题目所描述的那样对 A 进行划分。

```javascript
/*
* 解法：使用两个变量，一个为当前遍历i的最大值max，一个为已遍历的最大值leftMax，当A[i]大于leftMax时，证明i之前的数都比i小，left=新的max值，然后索引移到i开始算，直到遍历完成
*/
var partitionDisjoint = function(A) {
    
    let leftMax = A[0];
    let max = A[0];
    let index = 0;

    for(let i=0;i<A.length;i++) {
        max = Math.max(A[i],max);

        if( A[i] < leftMax ) {
            leftMax = max;
            index = i;  
        };
    };
    return index+1;
};
```
----
![leetcode截图](./image/1569579154.jpg)

10. 除自身以外数组的乘积
>给定长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，
>其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

说明：

请不要使用除法，且在 O(n) 时间复杂度内完成此题。

进阶：
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）

示例1:
```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

```javascript
/*
* 解法：先顺序遍历求出i之前的数的乘积，然后存入输出数组，再倒序遍历数组，求出i之后的数的乘积，然后输入数* 组索引对于的数相乘即得出答案
*/
var productExceptSelf = function(nums) {
    let res = [];
	let sum = 1;
	for(let i=0;i<nums.length;i++) {
		if(i != 0) {
			sum = nums[i-1] * sum ;
		};
		res.push(sum);
	};

	sum = 1;

	for(let i=nums.length-1;i>=0;i--) {
		if(i != nums.length-1) {
			sum = nums[i+1] * sum ;
		};
		res[i] = res[i] * sum;
	};
	
	return res;
};
```
----
![leetcode截图](./image/1569660429.jpg)


11. 分割回文串
>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
>返回 s 所有可能的分割方案。

示例1:
```
输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]
```

```javascript
/*
* 解法：使用递归回溯法，通过判断是否回文来剪枝。
*/
var partition = function(s) {
    let res = [];
	let result = [];
    let len = s.length;
	helper(0,s,res,len,[]);
    return res;
};

function helper(i,s,res,len,temp) {
	if(!s.length) {
        res.push([...temp]);
        return;
    };

	for(let j=i;j<s.length;j++) {
        let str = s.substring(0, j+1);
        let newS = s.substring(j+1);
        let onOff = isReserver(str);
        if(onOff) {
            temp.push(str);
            helper(i,newS,res,len,temp);
            temp.pop();
        }
	};
};

function isReserver(s) {
	let left = 0;
	let right = s.length-1;
	let onOff = true;
	while(left <= right) {
		if(s[left] != s[right]) {
			onOff = false;
			break;
		};
		left++;
		right--;
	};

	return onOff;
}
```
----
![leetcode截图](./image/1569731424.jpg)

12. 二叉树的中序遍历
>给定一个二叉树，返回它的中序遍历。

示例1:
```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
```

```javascript
/*
* 解法：使用递归
*/
 var inorderTraversal = function(root, res=[]) {
    if(!root) return res;
    inorderTraversal(root.left,res);
    res.push(root.val);
    inorderTraversal(root.right,res);
    return res;
};
```
----
![leetcode截图](./image/1569731424.jpg)

进阶: 递归算法很简单，你可以通过迭代算法完成吗？

```javascript
/*
* 解法：使用栈辅助完成
*/
var inorderTraversal = function(root) {
    let res = [];
    if(!root) return res;
    let stack = [];

    do{

        while(root) {
            stack.push(root);
            root = root.left;
        };

        if( stack.length ) {
            let node = stack.pop();
            res.push(node.val);
            root = node.right;
        };

    }while( root || stack.length );

    return res;
};
```
----
![leetcode截图](./image/1569754043.jpg)

13. 三数之和
>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例1:
```
例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

```javascript
/*
* 解法：使用递归
*/
 var threeSum = function(nums) {
    let res = [];
    nums.sort();
    helper(0, nums, res, [], 0);
    return res;
};

function helper(i, nums, res, temp, sum) {

    if(temp.length === 3) {
        if(sum === 0) {
            res.push([...temp]);
        };
        return;
    };
    let old = null;

    for(let j=i;j<nums.length;j++) {
        if( old === nums[j] ) {
            continue;
        }else {
            old = nums[j];
        };
        sum += nums[j];
        temp.push(nums[j]);
        helper(j+1, nums, res, temp, sum);
        sum -= temp.pop();
    };
};
```
**用递归的思路来解决当遇到大量数据的时候会导致运行时间过长，leetcode上倒数第311个测试用例有3000个数字，导致超出运行时间，因此需要找另外一种思路来解决**


**思路2：使用指针**
```javascript
/*
* 思路：先把数组排序，然后循环数组，当nums[i]等于正数就停止循环，因为如果三个数都为正数是不可能等于0的，然后建一个指针k=数组的长度-1，一个指针j=i+1;计算   *  nums[i]+nums[j]+nums[k]的总和s，如果s大于0.则证明nums[i]+nums[j]太大，需要移动nums[j],如果j移动到相同的数时要跳过，如果s小于0，则证明nums[k]太大，
* 需要把k往后移，如果s等于0，则记录下来，并把j和k各自移动一步，直到k>j条件不满足后跳出循环
*/
var threeSum = function(nums) {
    let res = [];
    let len = nums.length;
    
    if(len < 3) return res;

    nums.sort(function(a,b) {
        return a-b;
    });
    
    for(let i=0;i<len;i++) {
        let lastLen = len - i;
        if(nums[i] > 0 || lastLen<3 ) break;

        if( nums[i] === nums[i-1] ) continue;

        let j = i+1;
        let k = len-1;

        while(j < k) {
            let sum = nums[i] + nums[j] + nums[k];
            if( sum === 0 ) {
                res.push([nums[i],nums[j],nums[k]]);
                while(j < k) {
                    let old = nums[j];
                    j++;
                    if( old != nums[j] ) {
                        break;
                    };
                };
                while(j < k) {
                    let old = nums[k];
                    k--;
                    if( old != nums[k] ) {
                        break;
                    };
                };
            }else if(sum < 0){
                while(j < k) {
                    let old = nums[j];
                    j++;
                    if( old != nums[j] ) {
                        break;
                    };
                };
            }else {
                while(j < k) {
                    let old = nums[k];
                    k--;
                    if( old != nums[k] ) {
                        break;
                    };
                };
            };
        };
    };
    return res;
};
```
----
![leetcode截图](./image/1569838086.jpg)

14. 寻找重复数
> 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整
> 数。假设只有一个重复的整数，找出这个重复的数。

说明：

1. 不能更改原数组（假设数组是只读的）。
2. 只能使用额外的 O(1) 的空间。
3. 时间复杂度小于 O(n2) 。
4. 数组中只有一个重复的数字，但它可能不止重复出现一次。


示例:
```
输入: [1,3,4,2,2]
输出: 2
```

示例:
```
输入: [3,1,3,4,2]
输出: 3
```

**思路1：两个指针遍历**

```javascript
var findDuplicate = function(nums) {
	let len = nums.length;
	for(let i=0;i<nums.length;i++) {
		let j = len-1;
		while(j > i) {
			if(nums[j] === nums[i]) {
				console.log(nums[i])
				return nums[i];
			};
			j--;
		};
	};
};
```
----
![leetcode截图](./image/1569918977.jpg)

**思路2：使用二分查找法，由于数组有n+1的长度，并且由1-n的数字组成，假设数组长度为5，最大数为4，取中间数为2，然后遍历整个数组，找出比2小的全部数的总数，如果总数小于等于2，证明重复的数比2大，那么就把2之前的数给剔除掉，再求2到4之间的中位数，直到找到重复的数为止**

```javascript
var findDuplicate = function(nums) {
	let i = 0;
	let j = nums.length - 1;

	while(i<j) {
		let count = 0;
		let mid = Math.floor(i + (j-i)/2);
		for(let k=0;k<nums.length;k++) {
			if(nums[k] <= mid) {
				count++;
			};
		};
		if(count <= mid ) {
			i = mid+1;
		}else {
			j = mid;
		};
	};

	return i;
};
```
----
![leetcode截图](./image/1569919258.jpg)

15. 数组中的第K个最大元素
> 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k
> 个不同的元素。

说明：你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

示例:
```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

示例:
```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**思路1：把数组从大到小排序后，循环取出第k个数字**

```javascript
var findKthLargest = function(nums, k) {
    nums.sort(function(a,b) {
		return b-a;
	});

	for(let i=0;i<nums.length;i++) {
		if(i === k-1) {
			return nums[i];
		};
	};
};
```
----
![leetcode截图](./image/1570083384.jpg)

**思路2：利用快速排序的方法，在第一次排序找到pivot时，如果pivot的索引符合条件，就弹出pivot，如果比pivot小，则在pivot的左侧进行查找，如果比pivot大，在右侧查找**

```javascript
var findKthLargest = function(nums, k) {
	let len = nums.length;
	return qSort(nums, 0, len-1, len-k);
};

function qSort(nums,left,right, k) {
	let pivot = nums[right];
	let index = left - 1;
	let num;
	if(left<=right) {
		for(let i=left;i<=right;i++) {
			if(nums[i] <= pivot) {
				index++;
				let temp = nums[i];
				nums[i] = nums[index];
				nums[index] = temp;
			};
		};

		if(k === index) {
			return nums[index];
		}else if(k < index) {
			num = qSort(nums,left,index-1, k);
		}else {
			num = qSort(nums,index+1,right, k);
		};
	};

	return num;
};
```
----
![leetcode截图](./image/1570086636.jpg)

15. 二叉搜索树中第K小的元素
> 给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

示例:
```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
```

示例:
```
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3
```

进阶：
如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？

**思路:利用中序遍历，找到对应的值**

```javascript
var kthSmallest = function(root, k, res=[]) {
    if(!root) return;
	kthSmallest(root.left,k,res);
	res.push(root.val);
	kthSmallest(root.right,k,res);

	return res[k-1];
};

```
----
![leetcode截图](./image/1570176390.jpg)

15. 二叉树的层次遍历
> 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。


示例:
```
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]
```

**思路:实际上是广度优先搜索，利用队列的先出先出特性完成**

```javascript
var levelOrder = function(root) {
	if(!root) return [];
    let stack = [root];
	let stack2 = [];
	let res = [[root.val]];

	while(stack.length) {
		let node = stack.shift();

		if(node.left) {
			stack2.push(node.left);
		};

		if(node.right) {
			stack2.push(node.right);
		};

		if(!stack.length && stack2.length ){
			res.push(Array.from(stack2,x=>x.val));
			stack = stack2;
			stack2 = [];
		};

	};

	return res;
};
```
----
![leetcode截图](./image/1570262512.jpg)

**另一种更优雅的实现方式，利用递归完成**

```javascript
var levelOrder = function(root) {
	let res = [];

	helper(root,res,0);

	return res;
};

function helper(root,res,index) {
	if(!root) return [];

	if(!res[index]) {
		res[index] = [root.val];
	}else {
		res[index].push(root.val);
	};

	helper(root.left, res, index+1);
	helper(root.right, res, index+1);
};
```

16. 前 K 个高频元素
> 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。


示例1:
```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

示例2:
```
输入: nums = [1], k = 1
输出: [1]
```

**思路:先用哈希表存储数组中元素出现的次数，然后再用快速排序sort来按照次数从大到小排序，最后输出前面k个数字即可**

```javascript
var topKFrequent = function(nums, k) {
    let obj = {};

	for(let i=0;i<nums.length;i++) {
		let val = nums[i];
		if(obj[val]) {
			obj[val]++;
		}else {
			obj[val] = 1;
		};
	};

	let res = [],temp = [];

	for(let i in obj) {
		temp.push({
			val: i,
			num: obj[i]
		});
	};

	temp.sort(function(a,b){
		return b.num - a.num;
	});

	for(let i=0;i<k;i++) {
		res.push(+temp[i].val);
	};

	return res;
};
```
----
![leetcode截图](./image/1570349097.jpg)

17. 至少有K个重复字符的最长子串
> 找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。


示例1:
```
输入:
s = "aaabb", k = 3

输出:
3

最长子串为 "aaa" ，其中 'a' 重复了 3 次。
```

示例2:
```
输入:
s = "ababbc", k = 2

输出:
5

最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
```

**思路:先遍历一次数组，用一个对象存储数组每个数的出现次数，然后检查是否有出现次数少于k的值，然后获取这个值在字符串中的位置，如果有这个值的字符串肯定是不符合条件的，因此取这个值的前一段和后一段来继续做递归匹配筛选，存储每次递归符合条件的子串长度，然后取其中最大的值**

```javascript
var longestSubstring = function(s, k) {
    let res = [];
    let max = helper(s, k, []);
    console.log(max)
    return max;
};

function helper(s,k, res) {

    let obj = {};
    for(let i=0;i<s.length;i++) {
        if(obj[s[i]]) {
            obj[s[i]]++;
        }else {
            obj[s[i]] = 1;
        };
    };

    let min;

    for(let i in obj) {
        if( obj[i] < k ) {
            min = i;
        };
    };

    if(!min) {
        return s.length;
    };

    let index = s.indexOf(min);

    let left = helper(s.substring(0,index), k, res);
    let right = helper(s.substring(index+1), k, res);

    res.push(left);
    res.push(right);

    return Math.max(...res);

};
```
----
**ps：这种思路虽然通过，但是效率很差，后面会研究更好的解决方法**
![leetcode截图](./image/1570616779.jpg)