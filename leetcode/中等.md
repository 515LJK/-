## 中等难度

1. 子集
> 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:
```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

**思路：采用回溯法，递归得出结果**

```javascript
var subsets = function(nums) {
	let res = [];
	let temp = [];
	back(0, nums, res, temp);
	return res;
};

function back(i,nums,res,temp) {
	res.push([...temp]);
	for(let j=i;j<nums.length;j++) {
		temp.push(nums[j]);
		back(j+1,nums,res,temp);
		temp.pop();
	}
}
```
----
![leetcode截图](./image/1568464389.jpg)

**思路：迭代**
```javascript
/*
* 后面的数由前面的数迭代生成，比如输入[1,2,3], 首先子集有一个空子集[]，当遍历到1时，子集有空子集加1生* 成[1],此时子集有[[],[1]],当遍历到2时，子集有空子集加2生成[2]，以及[1]加2,生成[1,2],子集此时有[[],* [1],[2],[1,2]]，当遍历到3，子集有空子集加3生成[3]，以及[1]加3,[1,3],[2]加3,[2,3].[1,2]加3,[1,2,* 3],因此得出解[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]];
*
*/
var subsets = function(nums) {
	let res = [[]];

	for(let i=0;i<nums.length;i++) {
		for(let j=0,len=res.length;j<len;j++) {
			res.push(res[j].concat(nums[i]));
		}	
	}

	return res;
};
```
----
![leetcode截图](./image/1568466968.jpg)

2. 括号生成
>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

例如，给出 n = 3，生成结果为：
```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

**思路：采用回溯法**

```javascript
/*
* 解法：通过递归回溯进行解题，用两个变量标识左括号和右括号的数量，一个左括号对应一个右括号，当左括号的数* 量大于右括号时，右括号才能填入。
*/
var generateParenthesis = function(n) {

	let res = [];

	helper('', n, 0, 0, res);
	return res;
};

function helper(str, n, left, right, res) {
	if( str.length === n * 2) {
		res.push(str);
		return;
	};

	if(left < n) {
		helper(str + '(', n, left+1, right, res);
	};

	if(left > right) {
		helper(str + ')', n, left, right+1, res)
	}
};
```
----
![leetcode截图](./image/1568549540.jpg)
