## 简单难度

1. 两数之和

>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

**思路：一次循环数组，在哈希表中寻找目标值和当前数差值，如果找到，就输出索引，否则把当前值和所在索引存入哈希表中**

```javascript
var twoSum = function(nums, target) {
    var obj = {};
    
    for(let i=0;i<nums.length;i++) {
        let diff = target - nums[i];
        if(obj[diff] != undefined) {
            return [obj[diff], i];
        };
        obj[nums[i]] = i;
    }
    
    
    return [];
};
```
----
![leetcode截图](./image/1568449984.jpg)

2. 字母大小写全排列

>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

注意：
- S 的长度不超过12。
- S 仅由数字和字母组成。

示例:
```
示例:
输入: S = "a1b2"
输出: ["a1b2", "a1B2", "A1b2", "A1B2"]

输入: S = "3z4"
输出: ["3z4", "3Z4"]

输入: S = "12345"
输出: ["12345"]
```

**思路：采用回溯法**

```javascript
/*
* 用递归解题，当遇到字母时，转为大小写，分开两条分支组合字符串
*/
var letterCasePermutation = function(S) {
    let res = [];

	helper(0, S, res, '')
	return res;
};

function isz(s) {
	return /[a-z]/.test(s);
}

function isZ(s) {
	return /[A-Z]/.test(s);
}

function helper(i, S, res) {
	if(i === S.length) {
		res.push(S);
		temp = '';
		return;
	};

	helper(i+1,S,res)

	if(isZ(S[i])){
		S = S.substring(0, i) + S[i].toLowerCase() + S.substring(i+1);
		helper(i+1,S,res)
	}else if(isz(S[i])) {
		S = S.substring(0, i) + S[i].toUpperCase() + S.substring(i+1);
		helper(i+1,S,res)
	}
}
```
----
![leetcode截图](./image/1568549679.jpg)

3. 二进制手表

>二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。例如，二进制手表读取 “3:25”。
给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。

示例:
```
示例:
输入: n = 1
返回: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]
```

**思路：采用回溯法**

```javascript
/*
* 用递归解题，把时分用[0,0,0,0,0,0,0,0,0,0]来表示，求出不同位置1的全部排放排列，最后用[8,4,2,1,32,16,8,4,2,1]映射转为时间
*/
var readBinaryWatch = function(num) {
    let res = [];

    let time = new Array(10).fill(0);
    helper(0,num,res, time); 

    let newRes = [];
    for(let i=0;i<res.length;i++) {
        transfer(res[i],newRes)
    };

    return [...new Set(newRes)];
};

function helper(i,n, res, time) {
    if(i === n) {
        res.push([...time]);
        return;
    };

    for(let j=i;j<time.length;j++) {
        if(time[j] === 0) {
            time[j] = 1;
            helper(i+1,n,res,time);
            time[j] = 0;
        };
    }
};

function transfer(arr, newRes) {
    let check = [8,4,2,1,32,16,8,4,2,1];
    let sum = 0;
    let onOff = true;
    let hour = '';
    let minutes = '';
    for(let i=0;i<arr.length;i++) {
        if(arr[i]) {
            sum += check[i];
        };
        if(i === 3 && sum ) {
            if(sum < 12) {
                hour += sum;
            }else {
                onOff = false;
            }
            sum = 0;
        }
    };

    if(!onOff) {
        return;
    }

    if(sum) {
        if( sum < 60 ) {
            minutes += sum < 10? '0'+sum:sum;
        }else {
            onOff = false;
        }
    };

    if(onOff) {
        newRes.push(`${hour?hour:'0'}:${minutes?minutes:'00'}`);
    };
}
```
----
### 勉强写了一个能通过的，但效率很低，需要用剪枝来优化，后面有时间会优化一下 ###

![leetcode截图](./image/1568690449.jpg)

```javascript
/*
* 2019/9/21优化了回溯方法，做了剪枝处理以及对转化时间函数做了优化，因此效率有了提高。
*/
var readBinaryWatch = function(num) {
    let res = [];

    let time = new Array(10).fill(0);
    helper(0,num,res, time);
	return res;
};

function helper(i,n, res, time) {
    if(n == 0) {
		let times = transfer(time);
        times && res.push(times);
        return;
    };

    for(let j=i;j <= 10 - n;j++) {
        if(time[j] === 0) {
            time[j] = 1;
            helper(j+1,n-1,res,time);
            time[j] = 0;
        };
    }
};

function transfer(arr) {
    let hour = arr.slice(0, 4);
	let minute = arr.slice(4);
	let str = '';
	
	hour = parseInt(hour.join(''), 2);
	minute = parseInt(minute.join(''), 2);

	if(hour <= 11 && minute <= 59 ) {
		str = hour + ':' + (minute<10?'0'+minute:minute);
	};

	return str;
}
```

![leetcode截图](./image/1569053888.jpg)

4. 旋转数组

>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:
```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```
说明:

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。

**思路1：利用数组的shift和pop**

```javascript
var rotate = function(nums, k) {

    for(let i=1; i<=k;i++) {
        nums.unshift(nums.pop());
    };

    return nums;
};
```
----
![leetcode截图](./image/1569493047.jpg)

**思路2：反转，先把反转整个数组，然后反转0到k的元素和k到数组长度的元素**

```javascript
var rotate = function(nums, k) {
    k %= nums.length;
    helper(nums, 0, nums.length - 1);
    helper(nums, 0, k-1);
    helper(nums, k, nums.length - 1);
    return nums;
};


function helper(nums, left, right) {
    while( left < right ) {
        let temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
        left++;
        right--;
    };
}
```
----
![leetcode截图](./image/1569552962.jpg)

5. 反转字符串

>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例:
```
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

示例:
```
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

**思路：用两个指针分别遍历替换**

```javascript
var reverseString = function(s) {
    let left = 0;
	let right = s.length-1;

	while( left < right ) {
		let temp = s[left];
		s[left] = s[right];
		s[right] = temp;
		left++;
		right--;
	};

	return s;
};

```
----
![leetcode截图](./image/1569655239.jpg)

6.  缺失数字

>给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。

示例1:
```
输入: [3,0,1]
输出: 2
```

示例2:
```
输入: [9,6,4,2,3,5,7,0,1]
输出: 8
```

说明:
你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?

**思路1：求出0到n相加的总数，然后再遍历减去数组中的数，剩下的数就是缺失的数字**

```javascript
var missingNumber = function(nums) {
    let sum = 0;

	for(let i=0;i<=nums.length;i++) {
		sum += i;
	};

	for(let i=0;i<nums.length;i++) {
		sum -= nums[i];
	};

	return sum;
};

```
----
![leetcode截图](./image/1570350056.jpg)

**思路2：先排序，然后遍历找出缺失的数字**

```javascript
var missingNumber = function(nums) {
    nums.sort(function(a,b) {
		return a-b;
	});

	let num = 0;
	for(let i=0;i<nums.length;i++) {
		if( num++ != nums[i] ) {
			num--;
			break;
		}
	};
	
	return num;
};
```
----
![leetcode截图](./image/1570350362.jpg)

7. 找到所有数组中消失的数字

>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一>次。
>找到所有在 [1, n] 范围之间没有出现在数组中的数字。


示例:
```
输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
```

说明:
您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

**思路：利用返回的数组，先建立一个元素全部为0，长度为输入数组的长度的返回数组，然后遍历输入数组，把遍历的数和返回数组中对应的索引变为1，最后遍历输出数组，为0的值的索引push进输出数组，注意遍历前先把输入数组的长度用常量存储，最后输出数组的从长度到尾部的值即可**

```javascript
var findDisappearedNumbers = function(nums) {
    let len = nums.length;
	let res = new Array(len).fill(0);

	for(let i=0;i<len;i++) {
		res[nums[i]-1] = 1;
	};
	
	for(let i=0;i<len;i++) {
		if(!res[i]) {
			res.push(i+1);
		};
	};

	return res.slice(len);
};
```
![leetcode截图](./image/1570540625.jpg)

8. 实现 strStr()

>实现 strStr() 函数。
>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出
>needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例1:
```
输入: haystack = "hello", needle = "ll"
输出: 2
```

示例2:
```
输入: haystack = "aaaaa", needle = "bba"
输出: -1
```

说明:
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

**思路：实际上就是字符串匹配，有两种做法，一种是回溯匹配，一种是KMP算法**

```javascript
// 回溯匹配
var strStr = function(haystack, needle) {
    if(needle === "") return 0;

    let i = 0;
    let j = 0;

    let iLen = haystack.length;
    let jLen = needle.length;

    while(i<iLen && j<jLen ) {
        if(haystack[i] === needle[j]) {
            i++;
            j++;
        }else {
            i = i - j + 1;
            j=0;
        };

        if(j === needle.length) {
            return i-j;
        };
    };
    
    return -1;
};
```
![leetcode截图](./image/1570766549.jpg)

```javascript
// KMP算法
var strStr = function(haystack, needle) {
    if(needle === "") return 0;

    let i = 0;
    let j = 0;

    let iLen = haystack.length;
    let jLen = needle.length;

    while(i<iLen && j<jLen ) {

        if( j == -1 || haystack[i] === needle[j]) {
            i++;
            j++;
        }else {
            if( j > 0) {
				j = getNext(needle.slice(0, j));
			}else {
				j = -1;
			};
        };
    };

	if(j === needle.length) {
		return i-j;
	};
    
    return -1;
};

function getNext(str) {
	let next;
	let pre = [];
	let sub = [];
	let i = str.length;
	let newStr = str.slice(0, i+1);

	for(let j=0;j<i-1;j++) {
		pre[j] = newStr.slice(0, j+1);
		sub[j] = newStr.slice(-j-1);
		if(pre[j] === sub[j]) {
			next = pre[j].length;
		}
	};

	if(!next) {
		next = 0;
	}

	return next;
};
```
![leetcode截图](./image/1570963382.jpg)

9. 求众数

>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

示例1:
```
输入: [3,2,3]
输出: 3
```

示例2:
```
输入: [2,2,1,1,1,2,2]
输出: 2
```

说明:
你可以假设数组是非空的，并且给定的数组总是存在众数。

**思路1：哈希表**

```javascript
var majorityElement = function(nums) {
    let len = nums.length;
    let k = Math.ceil(len / 2);
    let obj = {};

    for(let i=0;i<len;i++) {
        if(obj[nums[i]]) {
            obj[nums[i]]++;
        }else {
            obj[nums[i]] = 1;
        }
    };

    for(let j in obj) {
        if(obj[j] >= k) return j;
    };
};
```
![leetcode截图](./image/1570877492.jpg)

**思路2**
```javascript
var majorityElement = function(nums) {
    let count = 0;
    let num;
    for(let i=0;i<nums.length;i++) {
        if(count === 0) {
            num = nums[i];
        };
        count += num === nums[i] ? 1 : -1;
    };
    return num;
};
```
![leetcode截图](./image/1571047924.jpg)

10. 移动零

>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:
```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

说明:
必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

**思路：循环数组，设置一个count记录当前零出现的次数，循环中当遇到非零的数时根据count往前移动count位，循环结束后再把最后count位的数变为0**

```javascript
var moveZeroes = function(nums) {
    let len = nums.length;
	let count = 0;

	for(let i=0;i<len;i++) {
		if(nums[i] === 0) {
			count++;
			continue;
		};

		nums[i - count] = nums[i];
	};

	for(let i=0;i<count;i++) {
		nums[len-1-i] = 0;
	};

	return nums;
};
```
![leetcode截图](./image/1571568687.jpg)