## 简单难度

1. 两数之和

>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

**思路：一次循环数组，在哈希表中寻找目标值和当前数差值，如果找到，就输出索引，否则把当前值和所在索引存入哈希表中**

```javascript
var twoSum = function(nums, target) {
    var obj = {};
    
    for(let i=0;i<nums.length;i++) {
        let diff = target - nums[i];
        if(obj[diff] != undefined) {
            return [obj[diff], i];
        };
        obj[nums[i]] = i;
    }
    
    
    return [];
};
```
----
![leetcode截图](./image/1568449984.jpg)

2. 字母大小写全排列

>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

注意：
- S 的长度不超过12。
- S 仅由数字和字母组成。

示例:
```
示例:
输入: S = "a1b2"
输出: ["a1b2", "a1B2", "A1b2", "A1B2"]

输入: S = "3z4"
输出: ["3z4", "3Z4"]

输入: S = "12345"
输出: ["12345"]
```

**思路：采用回溯法**

```javascript
/*
* 用递归解题，当遇到字母时，转为大小写，分开两条分支组合字符串
*/
var letterCasePermutation = function(S) {
    let res = [];

	helper(0, S, res, '')
	return res;
};

function isz(s) {
	return /[a-z]/.test(s);
}

function isZ(s) {
	return /[A-Z]/.test(s);
}

function helper(i, S, res) {
	if(i === S.length) {
		res.push(S);
		temp = '';
		return;
	};

	helper(i+1,S,res)

	if(isZ(S[i])){
		S = S.substring(0, i) + S[i].toLowerCase() + S.substring(i+1);
		helper(i+1,S,res)
	}else if(isz(S[i])) {
		S = S.substring(0, i) + S[i].toUpperCase() + S.substring(i+1);
		helper(i+1,S,res)
	}
}
```
----
![leetcode截图](./image/1568549679.jpg)

3. 二进制手表

>二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。例如，二进制手表读取 “3:25”。
给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。

示例:
```
示例:
输入: n = 1
返回: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]
```

**思路：采用回溯法**

```javascript
/*
* 用递归解题，把时分用[0,0,0,0,0,0,0,0,0,0]来表示，求出不同位置1的全部排放排列，最后用[8,4,2,1,32,16,8,4,2,1]映射转为时间
*/
var readBinaryWatch = function(num) {
    let res = [];

    let time = new Array(10).fill(0);
    helper(0,num,res, time); 

    let newRes = [];
    for(let i=0;i<res.length;i++) {
        transfer(res[i],newRes)
    };

    return [...new Set(newRes)];
};

function helper(i,n, res, time) {
    if(i === n) {
        res.push([...time]);
        return;
    };

    for(let j=i;j<time.length;j++) {
        if(time[j] === 0) {
            time[j] = 1;
            helper(i+1,n,res,time);
            time[j] = 0;
        };
    }
};

function transfer(arr, newRes) {
    let check = [8,4,2,1,32,16,8,4,2,1];
    let sum = 0;
    let onOff = true;
    let hour = '';
    let minutes = '';
    for(let i=0;i<arr.length;i++) {
        if(arr[i]) {
            sum += check[i];
        };
        if(i === 3 && sum ) {
            if(sum < 12) {
                hour += sum;
            }else {
                onOff = false;
            }
            sum = 0;
        }
    };

    if(!onOff) {
        return;
    }

    if(sum) {
        if( sum < 60 ) {
            minutes += sum < 10? '0'+sum:sum;
        }else {
            onOff = false;
        }
    };

    if(onOff) {
        newRes.push(`${hour?hour:'0'}:${minutes?minutes:'00'}`);
    };
}
```
----
### 勉强写了一个能通过的，但效率很低，需要用剪枝来优化，后面有时间会优化一下 ###

![leetcode截图](./image/1568690449.jpg)

```javascript
/*
* 2019/9/21优化了回溯方法，做了剪枝处理以及对转化时间函数做了优化，因此效率有了提高。
*/
var readBinaryWatch = function(num) {
    let res = [];

    let time = new Array(10).fill(0);
    helper(0,num,res, time);
	return res;
};

function helper(i,n, res, time) {
    if(n == 0) {
		let times = transfer(time);
        times && res.push(times);
        return;
    };

    for(let j=i;j <= 10 - n;j++) {
        if(time[j] === 0) {
            time[j] = 1;
            helper(j+1,n-1,res,time);
            time[j] = 0;
        };
    }
};

function transfer(arr) {
    let hour = arr.slice(0, 4);
	let minute = arr.slice(4);
	let str = '';
	
	hour = parseInt(hour.join(''), 2);
	minute = parseInt(minute.join(''), 2);

	if(hour <= 11 && minute <= 59 ) {
		str = hour + ':' + (minute<10?'0'+minute:minute);
	};

	return str;
}
```

![leetcode截图](./image/1569053888.jpg)

4. 旋转数组

>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:
```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```
说明:

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。

**思路1：利用数组的shift和pop**

```javascript
var rotate = function(nums, k) {

    for(let i=1; i<=k;i++) {
        nums.unshift(nums.pop());
    };

    return nums;
};
```
----
![leetcode截图](./image/1569493047.jpg)

**思路2：反转，先把反转整个数组，然后反转0到k的元素和k到数组长度的元素**

```javascript
var rotate = function(nums, k) {
    k %= nums.length;
    helper(nums, 0, nums.length - 1);
    helper(nums, 0, k-1);
    helper(nums, k, nums.length - 1);
    return nums;
};


function helper(nums, left, right) {
    while( left < right ) {
        let temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
        left++;
        right--;
    };
}
```
----
![leetcode截图](./image/1569552962.jpg)