## 树

1. 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
```javascript
/*
* 思路：前序遍历的第一个数字是根结点，取出后找到该节点在中序遍历的位置，左边是左子树，右边是右子树，
* 取出两个子树再分别递归，得出完整树
*/

function Node(data,left,right) {
	this.data = data;
    this.left = left;
    this.right = right;
}

function resetTree(preArr, midArr) {
	if(!preArr.length || !midArr.length) {
		return null;
	}
	let root = preArr[0];

	let node = new Node(root,null,null);
	
	let index = midArr.indexOf(root);

    // 中序遍历对应的索引也是前序遍历左右子树的分割点
	node.left = resetTree(preArr.slice(1,index+1),midArr.slice(0,index));
	node.right = resetTree(preArr.slice(index+1),midArr.slice(index+1));

	return node;
};

const preArr = [1, 2, 4, 7, 3, 5, 6, 8];
const midArr = [4, 7, 2, 1, 5, 3, 8, 6];

console.log(resetTree(preArr,midArr));

```

2. 输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。
```javascript
/*
* 思路：先找出二叉树B的根节点是否存在二叉树A的子树中，如果存在，则抽出两个子树，进一步递归作对比，两个子树之间的值
*/

function Node(value, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
};

function isChildTree(tree1, tree2) {
    let isChild = false;
    if( tree1 && tree2 ) {
        
        if(tree1.value === tree2.value) {
            result = isTreeCommon(tree1, tree2);
            console.log(result)
        }else {
            result = isChildTree(tree1.left, tree2);
            if(!result) {
                isChildTree(tree1.right, tree2);
            }
        }

    }

    return isChild;
}

function isTreeCommon(tree1, tree2) {
    let result = false;
    if(!tree2) {
        return true;
    };
    if(!tree1 || tree1.value != tree2.value ) {
        result = false;
    }else {
        result = isTreeCommon(tree1.left, tree2.left) && isTreeCommon(tree1.right, tree2.right);
    };
    return result;
};

let tree1 = new Node(1, new Node(2,new Node(4)), new Node(3))

let tree2 = new Node(2, new Node(4));

isChildTree(tree1,tree2)

```

3. 请完成一个函数，输入一个二叉树，该函数输出它的镜像
```javascript
/*
* 镜像即反转二叉树，先把根节点获得创建新子树，然后分别把旧树的右子树赋给新数的左子树，把旧树的左子树赋给新树的右子树
*/
function Node(value, left = null, right = null) {
    this.value = value;
    this.left = left;
    this.right = right;
};

let tree = new Node(1, new Node(2, new Node(4), new Node(6)), new Node(3, new Node(5)));

function mirrorTree(tree) {
    if(!tree) {
        return null;
    };

    let newTree = new Node(tree.value);

    if(tree.right) {
        newTree.left = mirrorTree(tree.right);
    };

    if(tree.left) {
        newTree.right = mirrorTree(tree.left);
    };
    
    return newTree;
}


console.log(tree,mirrorTree(tree));


```

4. 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。
```javascript
/*
* 思路：数组最后一项是二叉树的根节点，然后遍历数组直到根节点的前一项，找到比根节点大的第一项，以此为分割点，左边为左子树，右边为右子树，判断右子树必须全部值都* 比根节点大，否则返回false, 然后递归判断左子树和右子树直到只剩下一项。
*/

function isBST(arr) {
    if(!arr.length)return false;

    if(arr.length === 1)return true;

    let len = arr.length;
    let root = arr[len-1];
    let index = null;
    let result = false;
    
    for(let i=0;i<len-1;i++) {
        if(arr[i] > root) {
            index = i;
            break;
        }
    };

    if( index != null ) {
      let left = arr.slice(0, index);
      let right = arr.slice(index, len-1);

      if(Math.min(...right, root) === root ) {
        result = index === 0 || isBST(left) && isBST(right);
      };
    }
    
    return result;
}


console.log(isBST([5, 7, 6, 9, 11, 10, 8]))
```