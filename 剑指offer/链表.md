## 链表

1. 输入一个链表，从尾到头打印链表每个结点的值。
```javascript
/*
* 思路：先建一个简单的链表，然后遍历链表的结点，用一个数组模拟栈存储，然后栈弹出打印出全部值
*/

// node类包含两个属性：element保存结点上的数据，next用来保存指向下一个结点的链接
function Node(element){
	this.element = element;
	this.next = null;
	this.previous = null;
};

//LList类提供了对链表进行操作的方法。该类的功能包括插入删除结点、在列表中查找给定的值。
//链表只有一个属性，就是使用一个node对象来保存该链表的头结点,其中dispReverse方法从尾到头打印链表每个结点的值。
function LList(){
	this.head = new Node("head");
	this.find = find;
	this.insert = insert;
	this.remove = remove;
  	this.dispReverse = dispReverse;
}

function insert(newElement,item){
	var newNode = new Node(newElement);
	var current = this.find(item);
	newNode.next = current.next;
	newNode.previous = current;
	current.next = newNode;
}

function find(item){
	var currNode = this.head;
	while( currNode.element != item ){
		currNode = currNode.next;
	}
	return currNode;
}

function remove(item){
	var currNode = this.find(item);
	if(!(currNode.next == null)){
		currNode.previous.next = currNode.next;
		currNode.next.previous = currNode.previous;
		currNode.next = null;
		currNode.previous = null;
	}
}

function dispReverse(){
	let current = this.head;
	let arr = [];
	while(current.next != null) {
		arr.push(current.element);
		current = current.next;
	};

	arr.push(current.element);
	arr.reverse();
	
	console.log(arr.join(' '))
}

// 测试代码
var list = new LList();
list.insert('test','head');
list.insert('test2','test');
list.dispReverse();
```

2. 给定单向链表的头指针和一个结点指针，定义一个函数在 $O(1)$ 时间删除该结点。
```javascript
/*
* 思路：通过赋值，把目标结点的next赋值给目标结点，如果是尾结点，还是要按正常操作遍历链表找到结点，再删除结点
*
*/

function Node(element) {
    this.element = element;
    this.next = null;
};

function LList () {
    this.head = new Node('head');
    this.insert = insert;
    this.find = find;
	this.insert = insert;
    this.remove = remove;
}

function insert(newElement,item){
	var newNode = new Node(newElement);
	var current = this.find(item);
	newNode.next = current.next;
	current.next = newNode;
    return newNode;
}

function find(item){
	var currNode = this.head;
	while( currNode.element != item ){
		currNode = currNode.next;
	}
	return currNode;
};

function remove(head, node) {
    if( node === head || !node || !head ) {
        return;
    };

    if(node.next === null) {    // 尾结点
        let currNode = head;
        while(currNode.next != node) {
            currNode = currNode.next;
        };
        currNode.next = node = null;
        return;
    };

    let next = node.next;
    node.element = next.element;
    node.next = next.next;
};


let llist = new LList();

let test = llist.insert('test','head');
let test2 = llist.insert('test2','test');
let test3 = llist.insert('test3','test2');

llist.remove(llist.head, test2);
```

3. 输入一个单链表，输出该链表中倒数第 k 个结点。
```javascript
/*
* 思路：建立两个指针a和b，a先开始遍历链表，当a遍历到第k个结点的时候，b开始遍历，等a遍历到最后一个结点，b结点就是倒数第k个结点
*
*/
function Node(element) {
    this.element = element;
    this.next = null;
};

function LList () {
    this.head = new Node('head');
    this.insert = insert;
    this.find = find;
	this.insert = insert;
    this.findKNode = findKNode;
}

function insert(newElement,item){
	var newNode = new Node(newElement);
	var current = this.find(item);
	newNode.next = current.next;
	current.next = newNode;
    return newNode;
}

function find(item){
	var currNode = this.head;
	while( currNode.element != item ){
		currNode = currNode.next;
	}
	return currNode;
};


function findKNode(k) {

    if(k<=0) {
        return null;
    } 

    let a = this.head;
    let b = null;
    let index = 0;
    while( a.next != null ) {
        a = a.next;
        index++;
        if(index >= k ) {
            if(!b) {
                b = this.head;
            }else {
                b = b.next;
            }
        };
    };
    
    if(b) {
        b = b.next;
    };
    return b;
}

let list = new LList();

let test = list.insert('test','head');
let test2 = list.insert('test2','test');
let test3 = list.insert('test3','test2');

console.log(list.findKNode(5));
```

4. 定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。
```javascript
/*
* 思路：把当前结点的next和当前结点都用变量保存，然后移动到下一个结点，把next赋值给上一个结点，然后循环直到最后一个结点
*
*/
function Node(element) {
    this.element = element;
    this.next = null;
};

function LList () {
    this.head = new Node('head');
    this.insert = insert;
    this.find = find;
	this.insert = insert;
    this.reverse = reverse;
}

function insert(newElement,item){
	var newNode = new Node(newElement);
	var current = this.find(item);
	newNode.next = current.next;
	current.next = newNode;
    return newNode;
}

function find(item){
	var currNode = this.head;
	while( currNode.element != item ){
		currNode = currNode.next;
	}
	return currNode;
};

function reverse() {
    
    let node = this.head;
    let previous = null;

    while(node) {
        let next = node.next;
        node.next = previous;
        previous = node;
        node = next;
    };

    return previous;
};


let llist = new LList();

let test = llist.insert('test','head');
let test2 = llist.insert('test2','test');
let test3 = llist.insert('test3','test2');

console.log(llist.reverse());
```

5. 输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。
```javascript
/*
* 思路，建立两个指针a和b指向两个链表和一个新的指针node指向新链表，然后开始循环比较两者的大小，当a小于b时，node.next等于a,node指向a，a指针
* 继续向后移动，b同理,当a或者b为null时，即a链表或b链表已到结尾，把node.next指向剩下有值的链表即可。
*
*/
function Node(element) {
    this.element = element;
    this.next = null;
};

function LList () {
    this.head = new Node('head');
    this.insert = insert;
    this.find = find;
	this.insert = insert;
}

function insert(newElement,item){
	var newNode = new Node(newElement);
	var current = this.find(item);
	newNode.next = current.next;
	current.next = newNode;
    return newNode;
}

function find(item){
	var currNode = this.head;
	while( currNode.element != item ){
		currNode = currNode.next;
	}
	return currNode;
};

function join(list1,list2) {

    if(!list1 || !list2) {
        return;
    }

    let newList = new LList();
    let current = newList.head;

    let a = list1.head.next;
    let b = list2.head.next;

    while(b && a) {
        if( a.element < b.element ) {
            current.next = a;
            current = a;
            a = a.next;
        }else {
            current.next = b;
            current = b;
            b = b.next;
        };
    };

    if(!a) {
        current.next = b;
    };

    if(!b) {
        current.next = a;
    };

    return newList;
};

let llist1 = new LList();

llist1.insert('1','head');
llist1.insert('2','1');
llist1.insert('3','2');

let llist2 = new LList();
llist2.insert('4','head');
llist2.insert('5','4');
llist2.insert('6','5');

console.log(join(llist1,llist2));
```