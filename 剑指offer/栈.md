## 栈

1. 用两个栈实现一个队列。队列的声明如下:请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入结点和在队列头部删除结点的功能。
```javascript
/*
* 思路:用一个栈模拟先入，另一个栈模拟先出
*/
class List{
    constructor() {
        this.stack1 = [];
        this.stack2 = [];
        this.index = 0;
    }

    appendTail(item) {
        this.stack1.push(item); // 入栈
        this.stack2 = [];
        for(let i = this.stack1.length - this.index; i>=0; i--) {
            this.stack2.push(this.stack1[i]);
        }
    }

    deleteHead() {
        this.index++;
        return this.stack2.pop(); // 出栈
    }
}


let list = new List();

list.appendTail(1);
list.appendTail(2);
list.appendTail(3);

console.log(list.deleteHead());
console.log(list.deleteHead());
console.log(list.deleteHead());
```

2. 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数。在该栈中，调用 min、push 及 pop 的时间复杂度都是 O（1）。
```javascript
/*
* 思路：用两个变量分别存放当前索引和最小值索引，然后在push中进行比较，保存最小值的索引。
*
*/
class Stack {
    constructor() {
        this.dataStore = [];
        this.index = 0;
        this.minIndex = null;
    }

    push(item) {
        let min = this.minIndex != null && this.dataStore[this.minIndex] || Number.MAX_VALUE;
        
        if(item < min) {
            this.minIndex = this.index;
        };
        this.dataStore[this.index++] = item;
    }

    min() {
        return this.dataStore[this.minIndex];
    }

    pop() {
        return this.dataStore[this.index--];
    }

    show() {
        return this.dataStore.slice(0, this.index);
    }
}


let stack = new Stack();

stack.push(2);
stack.push(1);
stack.push(3);
stack.push(0);

console.log(stack.min())
```